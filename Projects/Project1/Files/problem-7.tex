\documentclass[catalog.tex]{subfiles}

% do not write anything in the preamble

\begin{document}

\def\pbname{Generalized suffix trees} %change this, do not use any number, just the name

\section{\pbname}

% only for overview, so short description (no more than 1-2 lines)
\begin{overview}
\item [Algorithm:] Generalized suffix trees(algo.~\ref{alg:\currfilebase})
	% -	must match the label of the algorithm
	% - when writing more than one algo use alg:\currfilebase_a, alg:\currfilebase_b, etc.
\item [Input:] a set of strings
\item [Complexity:] $\mathcal{O}(N)\footnote{Space complexity}, where\ N\ is\ the\ total\ length\ of\ strings$
\item [Data structure compatibility:] suffix trie, suffix array
\item [Common applications:] substring check, searching all patterns, longest repeated substring, build linear time suffix array, longest common substring, longest palindromic substring
\end{overview}


\begin{problem}{\pbname}
	Generalized suffix tree is a suffix tree made of a set of strings. A suffix tree is a compressed tree containing all the suffixes of the given string as edges and positions in the string as values of leaves.
\end{problem}


\subsection*{Description}
	Suffix Tree (Fig.~\ref{fig:\currfilebase_group1}) provides a particularly fast implementation for many important string operations, such as substring check, longest repeated substring. Suffix Tree (Fig.~\ref{fig:\currfilebase_1a}) consists of suffixes of the given string. The {\bf i}-th suffix is the substring that goes from the {\bf i}-th character of the string up to the {\bf last} character of the string, e.g., The first suffix of ``BANANA\$$\footnote{We use \$ to mark the end of the string}$'' is ``BANANA\$'' and the third suffix is ``NANA\$''. Generalized suffix tree (Fig.~\ref{fig:\currfilebase_1b}) is a suffix tree made of a set of strings. Generally, we merge the set of strings with ``\#'', e.g., ``CATABB\#GATAGACA\$''.


\begin{figure}[!htb]
	\centering
	\subfloat[Suffix tree of ``BANANA\$''\label{fig:\currfilebase_1a}]{\includegraphics[scale=0.4]{\currfilebase_1a}}
	\hspace{2cm} %\qquad
	\subfloat[Suffix tree of ``CATABB\#GATAGACA\$''\label{fig:\currfilebase_1b}]{\includegraphics[scale=0.4]{\currfilebase_1b}}
	\caption{Suffix tree figures generated by {\it Visualgo}\cite{visualgo.net}}
	\label{fig:\currfilebase_group1}
\end{figure}

	\subsubsection*{Complexity}
		The space complexity of generalized suffix tree is $\mathcal{O}(N)$, where $N$ is the sum of the length of the set of strings. Considering the maximum number of nodes in a generalized suffix tree, there are at most $N$ leaf nodes. And there are at most $N-1$ non-leaf nodes including the root, on account for suffix tree is commpressed, all non-leaf nodes must be branching. Hence, the maximum number of nodes in generalized suffix tree is $2N-1 = \mathcal{O}(N)$, which is much better than $\mathcal{O}(N^2)$ of suffix trie. Here is a simple example (Fig.~\ref{fig:\currfilebase_group2})


		\begin{figure}[!htb]
			\centering
			\includegraphics[scale=0.4]{\currfilebase_2}
			\caption{Suffix tree figure of ``AAAA\$'' generated by {\it Visualgo}\cite{visualgo.net}}
			\label{fig:\currfilebase_group2}
		\end{figure}


	\subsubsection*{Suffix Tree Construction\cite{UkkonenAlgo}}\label{alg:\currfilebase}
		In 1995, Esko Ukkonen published {\it On–line construction of suffix trees}\cite{Ukkonen}, which introduced the method to construct suffix tree in time linear in the length of the string. Different from trie, as we mentioned before, suffix tree is compressed, i.e., each edge is a substring [{\bf i}, {\bf j}]\footnote{For convenience, we use [{\bf i}, {\bf j}] to represent the substring which goes from {\bf i}-th character to the {\bf j}-th character of the string.} rather than a single character. It seems that we could build a suffix trie and compress it to obtain a suffix tree. However, the time complexity of suffix trie construction is $\mathcal{O}(bN)$, where $b$ is the length of the alphabet. Therefore, we introduce {\bf Ukkonen’s suffix tree construction}(algo.~\ref{alg:\currfilebase_pseudo1}). \par
		Before we start, we get two new terms, {\bf Explicit suffix tree} and {\bf Implicit suffix tree} (Fig.~\ref{fig:\currfilebase_group3}). Implicit suffix tree does not branch when a suffix is a substring of a suffix existing in the tree. In the example of implicit suffix tree of ``xabxa'' (Fig.~\ref{fig:\currfilebase_3a}), ``xa'' and ``a'' are substring of existing suffixes, but they are not shown ``explicitly''. To generate an implicit tree, we could simply insert each character of the string in turns. If the inserting character does not existing in the tree, get it a new edge. If not, skip it, then add the new character to each edge. Apparently, we construct an implicit suffix tree in time linear. Hence, the key to Ukkonen's suffix tree construction is to expand the tree into explicit suffix tree (Fig.~\ref{fig:\currfilebase_3b}) while generating an implicit suffix tree.


		\begin{figure}[!htb]
			\centering
			\subfloat[Implicit suffix tree of ``xabxa''\label{fig:\currfilebase_3a}]{\includegraphics[scale=0.6]{\currfilebase_3a}}
			\hspace{2cm} %\qquad
			\subfloat[Explicit suffix tree of ``xabxa\$''\cite{UkkonenAnimation}\label{fig:\currfilebase_3b}]{\includegraphics[scale=0.2]{\currfilebase_3b}}
			\caption{Implicit and explicit suffix trees}
			\label{fig:\currfilebase_group3}
		\end{figure}


		Now, let us go through Ukkonen's suffix tree construction of ``abcabxabcd\$''. As for the first character, ``a'', which is not in the tree (empty), thus create a new edge for it (Fig.~\ref{fig:\currfilebase_4a}). The value of the node is the position of ``a'' in the string, 1\footnote{In following figures, the number is not the value of the leaf, just the mark of nodes.}.


		\begin{figure}[!htb]
			\centering
			\includegraphics[scale=0.4]{\currfilebase_4a}
			\caption{Inserting ``a'' to the suffix tree\cite{UkkonenAnimation}}
			\label{fig:\currfilebase_4a}
		\end{figure}


		Then we deal with the second character ``b''. Create a new edge for ``b'', the value of the node is the position, 2. Add ``b'' to each edge.


		\begin{figure}[!htb]
			\centering
			\includegraphics[scale=0.4]{\currfilebase_4b}
			\caption{Inserting ``b'' to the suffix tree\cite{UkkonenAnimation}}
			\label{fig:\currfilebase_4b}
		\end{figure}


		Keep this operation, we insert the 4-th character ``a'' and get an implicit suffix tree (Fig.~\ref{fig:\currfilebase_4c}), which is already existing in the tree. We have to consider how to branch the tree.


		\begin{figure}[!htb]
			\centering
			\includegraphics[scale=0.35]{\currfilebase_4c}
			\caption{Inserting ``a'' to the suffix tree\cite{UkkonenAnimation}}
			\label{fig:\currfilebase_4c}
		\end{figure}

		Here we introduce two definitions, {\bf active point} and {\bf remainder}.
		\begin{itemize}
			\item Active point: (active\_node, active\_edge, active\_length)
			\item Remainder: an integer representing how many new suffix we are going to insert
		\end{itemize}
		We will explain the definitions in details during the construction. Now, we are dealing with the 4-th character ``a'', which is already in the tree, so we did not create a new edge for it. Thus, remainder is 1 for we still have 1 suffix ``a'' to be insert. Then active point is (root, a, 1), where {\it active\_node} is initialized to {\it root} which is not change, {\it active\_edge} is ``a'' representing that the edge beginning with ``a'' will be branch and {\it active length} is 1 representing length of ``a'' also the distance from the position where to spilt the edge to {\it active\_node} (Fig.~\ref{fig:\currfilebase_4d}).


		\begin{figure}[!htb]
			\centering
			\includegraphics[scale=0.3]{\currfilebase_4d}
			\caption{Active point and remainder\cite{UkkonenAnimation}}
			\label{fig:\currfilebase_4d}
		\end{figure}


		\newpage
		Keep going to next character ``b'', which is also existing in the tree. Hence, active point is updated to (root, a, 2). {\it active\_edge} is still ``a'' edge, but {\it active\_length} is 2, the length of ``ab''. Th remainder is updated to 2, we have ``ab'' and ``a'' to insert (Fig.~\ref{fig:\currfilebase_4e}).


		\begin{figure}[!htb]
			\centering
			\includegraphics[scale=0.3]{\currfilebase_4e}
			\caption{Inserting ``b'' to the suffix tree\cite{UkkonenAnimation}}
			\label{fig:\currfilebase_4e}
		\end{figure}


		When inserting next character ``x'', we find that it is not in the tree, so we split at the mark on the edge (Fig.~\ref{fig:\currfilebase_4e}). There is a new leaf in the suffix tree and its value will be assigned as 4. Active point and remainder are updated to (root, b, 1) and 2. But how? Actually, when it is ``x'''s turn, remainder is updated to 3, ``abx'',``bx'' and ``x''. After spliting, suffix ``abx'' is inserted and ``bx'' and ``x'' are left. Hence, remainder is 2, we will split at edge ``b'' next and the split position is after ``b'' (Fig.~\ref{fig:\currfilebase_4f}).


		\begin{figure}[!htb]
			\centering
			\includegraphics[scale=0.3]{\currfilebase_4f}
			\caption{Split at edge of ``a''\cite{UkkonenAnimation}}
			\label{fig:\currfilebase_4f}
		\end{figure}


		We keep doing the spliting process on the edge of ``b''. After spliting, we establish a link from Node4 to the new node, called {\bf suffix link} (Fig.~\ref{fig:\currfilebase_4g}), which is the key to make Ukkonen's construction in time linear. If the new non-leaf node is not the first one to be generated, establish suffix link to the previous non-leaf node. Then update active point and remainder to (root, none, 0) and 1. (root, 0) means to split at root (distance is zero), i.e., create a new edge for the last one suffix ``x''. For now, the insertion of ``x'' accomplished.


		\begin{figure}[!htb]
			\centering
			\includegraphics[scale=0.3]{\currfilebase_4g}
			\caption{Suffix link\cite{UkkonenAnimation}}
			\label{fig:\currfilebase_4g}
		\end{figure}


		Then we repeat the process for the next ``abc'', which covers the edge of ``ab''. Thus we determine {\it active\_length} based on Node4. Update active point and remainder to (Node4, c, 1) and 3. Then we insert ``d'', the split process begins. After inserting the suffix ``abcd'', we could change the {\it active\_node} by suffix link directly (Fig.~\ref{fig:\currfilebase_4i}), which make the algorithm in time linear.


		\begin{figure}[!htb]
			\centering
			\includegraphics[scale=0.3]{\currfilebase_4i}
			\caption{Suffix link\cite{UkkonenAnimation}}
			\label{fig:\currfilebase_4i}
		\end{figure}


		Repeat the process, Ukkonen's suffix tree construction completes (Fig.~\ref{fig:\currfilebase_4j}).


		\begin{figure}[!htb]
			\centering
			\includegraphics[scale=0.3]{\currfilebase_4j}
			\caption{Suffix link\cite{UkkonenAnimation}}
			\label{fig:\currfilebase_4j}
		\end{figure}


% add comment in the pseudocode: \cmt{comment}
% define a function name: \SetKwFunction{shortname}{Name of the function}
% use the defined function: \shortname{$variables$}
% use the keyword ``function'': \Fn{function name}, e.g. \Fn{\shortname{$var$}}
\SetKw{Continue}{continue}
\begin{Algorithm}[Ukkonen’s suffix tree construction\label{alg:\currfilebase_pseudo1}]
	% -	must match the reference in the overview
	% - when writing more than one algo use alg:\currfilebase_a, alg:\currfilebase_b, etc.
	%\SetKwFunction{myfunction}{MyFunction}
	\Input{A string $S$}
	\Output{A suffix tree}
	%	\Fn{\myfunction{$a,b$}}{
	%	}
	\BlankLine
	$S$ += ``\$''\\
	$activePosition \leftarrow (active\_node, active\_edge, active\_length)$\\
	$value \leftarrow 0$ \cmt{value to be assigned to leaf nodes}\\
  \For{i from $1$ to $len($S$)$}
	{
		$active\_node \leftarrow root$\\
		$active\_edge \leftarrow none$\\
		$active\_length \leftarrow 0$\\
		$remainder \leftarrow 0$\\
		Add $S[i]$ to each edge of leaf nodes\\
		\If{$S[i]$ is in any edge}
		{
			\If{$active\_edge$ == $none$}
			{
				$active\_edge \leftarrow S[i]$
			}
			$active\_length$ += $1$\\
			\If{$active\_length$ equals to the length of the edge including $S[i]$}
			{
				$active\_node \leftarrow $ the node that the edge leads to\\
				$active\_edge \leftarrow none$\\
				$active\_length \leftarrow 0$\\
			}
			$remainder$ += $1$\\
			\Continue
		}
		$ifFirst \leftarrow 1$\\
		$prevNode \leftarrow NULL$\\
		\While{$remainder > 0$}
		{
			Generate a new node $split$ on $active\_edge$ at $active\_length$ position\\
			Generate a node $leaf$ linked to $split$ with edge $S[i]$\\
			$leaf.value \leftarrow value$\\
			$value$ += $1$\\
			$remainder$ -= $1$\\
			\If{ifFirst}
			{
				$prevNode \leftarrow split$\\
				$ifFirst \leftarrow 0$
			}
			\Else
			{
				$split$ linked to $prevNode$\\
				$prevNode \leftarrow split$
			}
			\If{$active\_node$ == $root$}
			{
				$active\_edge \leftarrow S[index(active\_edge)$ + $1]$\\
				$active\_length$ -= $1$
				\Continue
			}
			\If{$active\_node$ has suffix link}
			{
				$active\_node \leftarrow$ the node $active\_node$ links to\\
			}
			\Else
			{
				$active\_node \leftarrow root$
			}
		}
	}
	\Ret $root$

\end{Algorithm}
Time complexity: $\mathcal{O}(N)$

	\subsubsection*{Applications}
	\begin{itemize}
		\item {\bf Longest Repeated Substring\cite{visualgo.net}}\par
		Construct a suffix tree, find the deepest non-leaf node. The path from root to the node is the longest repeated substring of the string.
		\item {\bf Longest Common Substring\cite{visualgo.net}}\par
		Construct a suffix tree of ``string1 + \# + string2 + \$'', find the deepest non-leaf node. The path from root to the node is the longest common substring of string1 and string2.
		\item {\bf Longest Palindromic Substring\cite{GeeksforGeeks}}\par
		Construct a suffix tree of ``string + \# + reverse of string + \$'', find the deepest non-leaf node. The path from root to the node is the longest palindromic substring of the string.
	\end{itemize}


% include references where to find information on the given problem using latex bibliography
% insert references in the text (\cite{}) and write bibliography file in problem-nb.bib (replace nb with the problem number)
% prefer books, research articles, or internet sources that are likely to remain available over time
% as much as possible offer several options, including at least one which provide a detailed study of the problem
% if available include links to programs/code solving the problem
% wikipedia is NOT acceptable as a unique reference
\singlespacing
\printbibliography[title={References.},resetnumbers=true,heading=subbibliography]

\end{document}
